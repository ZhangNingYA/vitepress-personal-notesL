---
title: 隔离级别中，幻读和不可重复读的区别是什么？
date: 2025-12-20
---
# 隔离级别详解：幻读与不可重复读的区别

## 1. 原问题
**隔离级别中，幻读（Phantom Read）和不可重复读（Non-Repeatable Read）的区别是什么？**

---

## 2. 相关考点
在数据库事务与锁机制的面试中，这是一个非常基础但容易混淆的考点，通常关联以下内容：
* **事务的ACID特性**：特别是I（Isolation 隔离性）。
* **四种隔离级别**：Read Uncommitted, Read Committed, Repeatable Read, Serializable。
* **MVCC（多版本并发控制）**：快照读与当前读的区别。
* **锁机制**：行锁（Record Lock）与间隙锁（Gap Lock/Next-Key Lock）的作用。
* **MySQL InnoDB的特性**：为什么MySQL的RR级别能很大程度上避免幻读。

---

## 3. 核心知识点讲解

### 3.1 本质区别一句话总结
* **不可重复读**：重点在于**修改（Update）和删除（Delete）**。即“同样的记录，两次读取的值不一样”。
* **幻读**：重点在于**新增（Insert）**。即“同样的条件，两次查询出来的记录数不一样”。



### 3.2 详细场景对比

#### 1. 不可重复读 (Non-Repeatable Read)
* **场景**：事务A先读取了id=1的记录，显示工资为1000。此时事务B介入，将id=1的工资修改为2000并提交。事务A再次读取id=1的记录，发现工资变成了2000。
* **问题**：同一个事务内，读取**同一行**数据，结果前后不一致。
* **解决手段**：**行级锁（Record Lock）**或 MVCC。锁定被读取的行，阻止其他事务修改。

#### 2. 幻读 (Phantom Read)
* **场景**：事务A查询“工资>1000”的员工，发现有5人。此时事务B介入，**插入**了一个新员工，工资为3000并提交。事务A再次查询“工资>1000”的员工，发现变成了6人。
* **问题**：同一个事务内，用**相同的范围条件**查询，结果集里多出了“幽灵”般的行。
* **解决手段**：单纯锁行是不够的，因为新插入的行之前并不存在。需要**间隙锁（Gap Lock）**，锁定索引记录之间的空隙，阻止插入。

### 3.3 对比表

| 特性 | 不可重复读 | 幻读 |
| :--- | :--- | :--- |
| **关注点** | 数据的**内容**变化 | 数据的**数量**变化 |
| **触发操作** | Update, Delete | Insert |
| **锁定范围** | 只需要锁住**满足条件的行** | 需要锁住**满足条件的行 + 行之间的间隙** |
| **标准SQL解决级别** | Repeatable Read (可重复读) | Serializable (串行化) |

---

## 4. 类似题目

1.  **题目一**：MySQL InnoDB引擎默认的隔离级别是什么？它在解决幻读问题上与其他数据库有何不同？
2.  **题目二**：什么是**MVCC**？它是如何解决不可重复读的？
3.  **题目三**：什么是**间隙锁（Gap Lock）**和**临键锁（Next-Key Lock）**？它们在防止幻读中起什么作用？

---

## 5. 对应的答案

### 答案一：MySQL默认隔离级别与幻读
* **默认级别**：**Repeatable Read (RR)**。
* **特殊性**：
    * 按照SQL标准，RR级别只需要解决不可重复读，不需要解决幻读。
    * 但MySQL InnoDB通过引入**Next-Key Lock**（行锁+间隙锁）算法，在RR级别下就已经解决了**当前读**（Current Read，如`SELECT FOR UPDATE`）的大部分幻读问题。
    * 对于**快照读**（普通的`SELECT`），InnoDB通过MVCC保证不出现幻读。

### 答案二：MVCC原理与不可重复读
* **MVCC (Multi-Version Concurrency Control)**：多版本并发控制。
* **原理**：
    * 每行数据都有隐藏列（创建版本号、删除版本号/回滚指针）。
    * 事务启动时会申请一个**Read View**（读视图）。
* **解决不可重复读**：
    * 在RR级别下，事务**第一次**执行SELECT语句时生成Read View。
    * 后续该事务内所有的SELECT都复用这个Read View，只读取“版本号早于或等于当前事务版本”的数据。即使其他事务修改并提交了数据，由于Read View没变，当前事务看到的依然是旧版本的数据。

### 答案三：Gap Lock 与 Next-Key Lock
这是MySQL在RR级别下防止幻读的核心机制：
1.  **Record Lock**：锁住具体的索引项（锁单行）。
2.  **Gap Lock (间隙锁)**：锁住两个索引项之间的**空隙**，不包含记录本身。
    * *作用*：防止其他事务在这个空隙中`INSERT`新数据。
3.  **Next-Key Lock**：**Record Lock + Gap Lock**。
    * *定义*：锁住记录本身，加上记录之前的间隙（左开右闭区间）。
    * *结论*：通过锁住查询范围涉及的所有间隙，彻底杜绝了其他事务“偷偷插入数据”的可能性，从而解决幻读。
# 隔离级别中幻读与不可重复读的区别

## 1. 原问题
**隔离级别中，幻读和不可重复读的区别是什么？**

---

## 2. 相关考点
该问题是事务隔离与并发异常的高频考点，通常涉及：
- **ACID与事务隔离（Isolation）**：并发控制目标与边界
- **并发异常三件套**：脏读（Dirty Read）、不可重复读（Non-repeatable Read）、幻读（Phantom Read）
- **SQL隔离级别**：READ UNCOMMITTED / READ COMMITTED / REPEATABLE READ / SERIALIZABLE
- **实现机制**：
  - 锁：行锁、间隙锁（Gap Lock）、Next-Key Lock、范围锁
  - MVCC：快照读（Snapshot Read）、当前读（Current Read）
- **数据库差异**：不同DB对隔离级别与“幻读”定义/实现存在差异（尤其 MySQL/InnoDB）

---

## 3. 知识点
- **不可重复读**：同一事务内对**同一行（同一主键记录）**的两次读取结果不一致，原因是另一个事务在两次读取之间**更新或删除**了该行并提交。
- **幻读**：同一事务内对**同一查询条件（一个范围/谓词）**的两次执行，返回的**行集合数量或成员发生变化**，原因是另一个事务在两次查询之间**插入或删除**了满足条件的新行并提交。
- **核心差异一句话**：
  - 不可重复读关注“**同一行的值变了**”
  - 幻读关注“**符合条件的行集合变了**”（多了/少了“幻影行”）

---

## 4. 核心知识点讲解

### 4.1 不可重复读（Non-repeatable Read）
#### 4.1.1 定义（面试标准表述）
在同一事务中，两次读取同一条记录，结果不一致；通常由其他事务对该记录进行了**UPDATE/DELETE并提交**导致。

#### 4.1.2 典型示例
- 事务T1：
  1. `SELECT balance FROM account WHERE id=1;` 结果：100
  2. （期间T2修改并提交）
  3. `SELECT balance FROM account WHERE id=1;` 结果：80（与第一次不同）
- 事务T2：
  - `UPDATE account SET balance=80 WHERE id=1; COMMIT;`

#### 4.1.3 本质原因
- 并发事务对“同一行”进行了修改，导致同一事务内再次读到新值。

---

### 4.2 幻读（Phantom Read）
#### 4.2.1 定义（面试标准表述）
在同一事务中，两次执行同一范围条件查询，返回的记录集合发生变化（多出或少了行），通常由其他事务对满足条件的记录进行了**INSERT/DELETE并提交**导致。

#### 4.2.2 典型示例
- 事务T1：
  1. `SELECT * FROM orders WHERE amount > 1000;` 返回：10行
  2. （期间T2插入满足条件的新订单并提交）
  3. `SELECT * FROM orders WHERE amount > 1000;` 返回：11行（多出“幻影行”）
- 事务T2：
  - `INSERT INTO orders(id, amount) VALUES(999, 2000); COMMIT;`

#### 4.2.3 本质原因
- 并发事务对“谓词范围”内的数据做了增删，改变了满足条件的行集合。

---

### 4.3 二者对比总结（强记忆点）

| 对比维度 | 不可重复读 | 幻读 |
|---|---|---|
| 变化对象 | 同一条记录（同一行）的值变化 | 满足条件的记录集合变化（多/少行） |
| 常见触发操作 | UPDATE / DELETE（修改已有行） | INSERT / DELETE（增删符合条件的行） |
| 查询特征 | 通常是按主键/唯一键定位单行 | 通常是范围条件/谓词条件查询 |
| 典型表现 | 第二次读到不同字段值 | 第二次查到新增“幻影行”或缺失行 |
| 常见治理手段 | MVCC快照 / 行锁（视隔离级别） | 范围锁（Gap/Next-Key）或 SERIALIZABLE |

---

### 4.4 与隔离级别的关系（面试常用结论）
- **READ COMMITTED（读已提交）**
  - 通常可避免脏读
  - 但可能发生不可重复读、幻读（视实现）
- **REPEATABLE READ（可重复读）**
  - 设计目标是避免不可重复读（同一行多次读一致）
  - 幻读是否完全避免取决于数据库实现与读写方式（尤其“当前读”）
- **SERIALIZABLE（可串行化）**
  - 理论上可避免幻读（通过强制串行化或范围锁/谓词锁）

> 重要补充（常被追问）：在很多MVCC实现里，“普通SELECT”是快照读，可能天然避免不可重复读；但在涉及更新的“当前读”（如 `SELECT ... FOR UPDATE`、`UPDATE`）中，为防止并发插入导致逻辑异常，往往仍需要范围锁来处理幻读问题。

---

## 5. 类似题目
1. **题目一**：脏读、不可重复读、幻读分别是什么？各自在哪些隔离级别下可能发生？
2. **题目二**：MVCC如何实现“可重复读”？它解决了哪些问题，又解决不了哪些问题？
3. **题目三**：什么是间隙锁（Gap Lock）/Next-Key Lock？它们为什么能防止幻读？

---

## 6. 对应的答案

### 答案一：三种并发异常与隔离级别关系（概念层）
- **脏读**：读到未提交数据（READ UNCOMMITTED可能发生）。
- **不可重复读**：同一行两次读到不同值（READ COMMITTED可能发生）。
- **幻读**：同一条件两次查询行集合变化（READ COMMITTED / REPEATABLE READ 视实现与读方式可能发生）。
- **SERIALIZABLE**：通过最强隔离避免上述异常（代价是并发度显著下降）。

---

### 答案二：MVCC与可重复读
- MVCC通过为事务提供一致性快照，使同一事务内多次“快照读”看到同一个版本，从而避免不可重复读。
- 但对“当前读/加锁读”或需要保证“范围内不被插入”的业务约束，仍可能需要范围锁，否则会出现幻读相关问题（例如先查范围再插入导致约束被破坏）。

---

### 答案三：Gap/Next-Key锁为何能防止幻读
- **Gap Lock**锁定索引中的“间隙区间”，阻止其他事务在该区间插入新记录。
- **Next-Key Lock** = 行锁 + 间隙锁，既锁住已有记录，也锁住相邻间隙，防止范围内插入/修改导致集合变化。
- 结果：同一事务内针对某范围的加锁读/更新时，其他事务无法插入满足条件的新行，从而避免幻读。
